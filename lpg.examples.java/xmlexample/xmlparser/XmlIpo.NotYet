--
-- This XML is a schema-specific parser for the IPO schema.
--

%options escape=$
%options var=nt
%options la=15
%options table=java
%options fp=XmlParser,prefix=Char_
%options error-maps
%options scopes
%options margin=8
%options single_productions
%options package=xmlparser
%options template=dtUnifiedTemplate.g

$Import
    XmlNSParser.g
$DropSymbols
    element
$End

----------------------------------------------------------------------------------------------------------
--
-- The following rules will be automatically generated!
--
$Rules
    WhiteSpaces? ::= $Empty
                   | WhiteSpaces
    element ::= '<' 'N' 'a' 'm' 'e' Attributes WhiteSpaces? '/' '>'
              | '<' 'N' 'a' 'm' 'e' Attributes WhiteSpaces? '>'  content '<' '/' 'N' 'a' 'm' 'e' WhiteSpaces? '>'

    element ::= @purchaseOrder
        /.$NoAction./
    
    element ::= @comment
        /.$NoAction./
    
    @@Attribute ::= 'xmlns' Eq AttValue
        /.$NoAction./

    @@Attribute ::= type Eq AttValue
        /.$NoAction./
    
    @@Attribute ::= nil Eq AttValue
        /.$NoAction./
    
    @@Attribute ::= schemaLocation Eq AttValue
        /.$NoAction./
    
    @@Attribute ::= noNamespaceSchemaLocation Eq AttValue
        /.$NoAction./
    
    @@Attribute ::= orderDate Eq AttValue
        /.$NoAction./

    @@Attribute ::= country Eq AttValue
        /.$NoAction./

    @@Attribute ::= partNum Eq AttValue
        /.$NoAction./
    
    @@Attributes ::= $empty
        /.$NoAction./

    @@Attributes ::= @@Attributes @@Attribute
        /.$NoAction./

    @purchaseOrder ::= '<purchaseOrder' purchaseOrderSetup @PurchaseOrderType '</' purchaseOrder>
        /.$NoAction./

    purchaseOrderSetup ::= '>'
        /.$Action
        $DefaultHeader
        {
            scanner -> type.SetKind(TK_PurchaseOrderType);
            scanner -> type.prefix_index = 4;
            scanner -> type.MarkTypeSpecific();

            bool orderDate = false;

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                switch(attribute.Kind())
                {
                    case TK_orderDate:
                        if (orderDate)
                        {
                            cout << "Error detected at location "
                                 << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                                 << ". The attribute \"";
                                 for (int i = 0; i < attribute.qname.local_part.length; i++)
                                     cout << attribute.qname.local_part.start[i];
                                 cout << "\" was specified more than once.\n";
                        }
                        else
                        {
                            orderDate = true;
                            if (! scanner -> IsDate(attribute.att_value.start + 1)) // +1 to skip the initial quote
                            {
                                cout << "Error detected at location "
                                     << (attribute.att_value.start - scanner -> Buffer() + 1)
                                     << ". Invalid date.\n";
                            }
                        }
                        break;
                    default:
                        cout << "Error detected at location "
                             << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                             << ". The attribute \"";
                        for (int i = 0; i < attribute.qname.local_part.length; i++)
                            cout << attribute.qname.local_part.start[i];
                        cout << "\" is not valid.\n";
                }
            }
        }
        ./
    
    @comment ::= '<comment' commentSetup CharData '</' comment>
        /.$NoAction./

    commentSetup ::= '>'
        /.$CharDataElementWithoutAttributesAction
        void xmlact::CheckCharDataElementWithoutAttributes ()
        {
            scanner -> type.MarkTypeSpecific();
            if (scanner -> type.IsNotSpecified())
                scanner -> Set_CharData_code(ExtendedScanner::CharData_CharData);
            else
            {
                //
                // TODO: set CharData_code appropriately !
                //
                scanner -> type.Reset();
            }

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                cout << "Error detected at location "
                     << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                     << ". The attribute \"";
                for (int i = 0; i < attribute.qname.local_part.length; i++)
                    cout << attribute.qname.local_part.start[i];
                cout << "\" is not valid.\n";
            }
        }
        ./
    
    @PurchaseOrderType ::= @shipTo @billTo @items
        /.$NoAction./
    
    @PurchaseOrderType ::= @shipTo @billTo @comment @items
        /.$NoAction./
    
--
-- Since the 'shipTo' element appears only once in this schema, this rule is not needed
--
--    @shipToName ::= '<shipTo'
--        /.$Action
--        $DefaultHeader
--        {
--            scanner -> type.SetKind(TK_Address);
--            scanner -> type.prefix_index = 4;
--        }
--        ./

    --
    -- Note that we use the terminal '<shipTo' here instead of the nonterminal
    -- @shipToName. This is because by default, the scanner assumes that a 'shipTo'
    -- element is of type TK_Address.
    --
    @shipTo ::= '<shipTo' '>' AddressSetup @Address '</' shipTo>
        /.$NoAction./
    
    --
    -- Note that we use the terminal '<shipTo' here instead of the nonterminal
    -- @shipToName. This is because by default, the scanner assumes that a 'shipTo'
    -- element is of type TK_Address.
    --
    @shipTo ::= '<shipTo' '>' USAddressSetup @USAddress '</' shipTo>
        /.$NoAction./

    --
    -- Note that we use the terminal '<shipTo' here instead of the nonterminal
    -- @shipToName. This is because by default, the scanner assumes that a 'shipTo'
    -- element is of type TK_Address.
    --
    @shipTo ::= '<shipTo' '>' UKAddressSetup @UKAddress '</' shipTo>
        /.$NoAction./

--
-- Since the 'billTo' element appears only once in this schema, this rule is not needed
--
--    @billToName ::= '<billTo'
--        /.$Action
--        $DefaultHeader
--        {
--            scanner -> type.SetKind(TK_Address);
--            scanner -> type.prefix_index = 4;
--        }
--        ./

    --
    -- Note that we use the terminal '<billTo' here instead of the nonterminal
    -- @billToName. This is because by default, the scanner assumes that a 'billTo'
    -- element is of type TK_Address.
    --
    @billTo ::= '<billTo' '>' AddressSetup @Address '</' billTo>
        /.$NoAction./
    
    --
    -- Note that we use the terminal '<billTo' here instead of the nonterminal
    -- @billToName. This is because by default, the scanner assumes that a 'billTo'
    -- element is of type TK_Address.
    --
    @billTo ::= '<billTo' '>' USAddressSetup @USAddress '</' billTo>
        /.$NoAction./
    
    --
    -- Note that we use the terminal '<billTo' here instead of the nonterminal
    -- @billToName. This is because by default, the scanner assumes that a 'billTo'
    -- element is of type TK_Address.
    --
    @billTo ::= '<billTo' '>' UKAddressSetup @UKAddress '</' billTo>
        /.$NoAction./
    
    @items ::= '<items' itemsSetup @Items '</' items>
        /.$NoAction./

    itemsSetup ::= '>'
        /.$Action
        $DefaultHeader
        {
            scanner -> type.SetKind(TK_Items);
            scanner -> type.prefix_index = 4;
            scanner -> type.MarkTypeSpecific();

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                cout << "Error detected at location "
                     << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                     << ". The attribute \"";
                for (int i = 0; i < attribute.qname.local_part.length; i++)
                    cout << attribute.qname.local_part.start[i];
                cout << "\" is not valid.\n";
            }
        }
        ./
    
    AddressSetup ::= Address
        /.$Action
        $DefaultHeader
        {
            bool country = false;

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                switch(attribute.Kind())
                {
                    case TK_country:
                        if (country)
                        {
                            cout << "Error detected at location "
                                 << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                                 << ". The attribute \"";
                                 for (int i = 0; i < attribute.qname.local_part.length; i++)
                                     cout << attribute.qname.local_part.start[i];
                                 cout << "\" was specified more than once.\n";
                        }
                        else
                        {
                            country = true;
                            if (attribute.att_value.length != 4 ||
                                (! (Ascii::IsUpper(attribute.att_value.start[1]) &&
                                    Ascii::IsUpper(attribute.att_value.start[2]))))
                            {
                                cout << "Error detected at location "
                                     << (attribute.att_value.start - scanner -> Buffer() + 1)
                                     << ": Invalid attribute value for \"country\" in type Address.\n";
                            }
                        }
                       break;
                    default:
                        cout << "Error detected at location "
                             << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                             << ". The attribute \"";
                        for (int i = 0; i < attribute.qname.local_part.length; i++)
                            cout << attribute.qname.local_part.start[i];
                        cout << "\" is not valid.\n";
                }
            }
        }
        ./
    
    USAddressSetup ::= USAddress
        /.$Action
        $DefaultHeader
        {
            bool country = false;

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                switch(attribute.Kind())
                {
                    case TK_country:
                        if (country)
                        {
                            cout << "Error detected at location "
                                 << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                                 << ". The attribute \"";
                                 for (int i = 0; i < attribute.qname.local_part.length; i++)
                                     cout << attribute.qname.local_part.start[i];
                                 cout << "\" was specified more than once.\n";
                        }
                        else
                        {
                            country = true;
                            if (attribute.att_value.length != 4 ||
                                attribute.att_value.start[1] != 'U' ||
                                attribute.att_value.start[2] != 'S')
                            {
                                cout << "Error detected at location "
                                     << (attribute.att_value.start - scanner -> Buffer() + 1)
                                     << ". Attribute value \"US\" was expected.\n";
                            }
                        }
                       break;
                    default:
                        cout << "Error detected at location "
                             << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                             << ". The attribute \"";
                        for (int i = 0; i < attribute.qname.local_part.length; i++)
                            cout << attribute.qname.local_part.start[i];
                        cout << "\" is not valid.\n";
                }
            }
        }
        ./
    
    UKAddressSetup ::= UKAddress
        /.$Action
        $DefaultHeader
        {
            bool country = false;

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                switch(attribute.Kind())
                {
                    case TK_country:
                        if (country)
                        {
                            cout << "Error detected at location "
                                 << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                                 << ". The attribute \"";
                                 for (int i = 0; i < attribute.qname.local_part.length; i++)
                                     cout << attribute.qname.local_part.start[i];
                                 cout << "\" was specified more than once.\n";
                        }
                        else
                        {
                            country = true;
                            if (attribute.att_value.length != 4 ||
                                attribute.att_value.start[1] != 'U' ||
                                attribute.att_value.start[2] != 'K')
                            {
                                cout << "Error detected at location "
                                     << (attribute.att_value.start - scanner -> Buffer() + 1)
                                     << ". Attribute value \"US\" was expected.\n";
                            }
                        }
                       break;
                    default:
                        cout << "Error detected at location "
                             << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                             << ". The attribute \"";
                        for (int i = 0; i < attribute.qname.local_part.length; i++)
                            cout << attribute.qname.local_part.start[i];
                        cout << "\" is not valid.\n";
                }
            }
        }
        ./
    
    @Address ::= @name @street @city 
        /.$NoAction./
    
    @USAddress ::= @name @street @city @state @zip 
        /.$NoAction./
    
    @UKAddress ::= @name @street @city @state @postcode 
        /.$NoAction./
    
    @name ::= '<name' nameSetup CharData '</' name>
        /.$NoAction./
    
    nameSetup ::= '>'
        /.$ShareCharDataElementWithoutAttributesAction./
    
    @street ::= '<street' streetSetup CharData '</' street>
        /.$NoAction./
    
    streetSetup ::= '>'
        /.$ShareCharDataElementWithoutAttributesAction./
    
    @city ::= '<city' citySetup CharData '</' city>
        /.$NoAction./
    
    citySetup ::= '>'
        /.$ShareCharDataElementWithoutAttributesAction./
    
    @state ::= '<state' stateSetup CharData '</' state>
        /.$NoAction./
    
    stateSetup ::= '>'
        /.$ShareCharDataElementWithoutAttributesAction./
    
    @zip ::= '<zip' zipSetup CharData '</' zip>
        /.$NoAction./
    
    zipSetup ::= '>'
        /.$Action
        $DefaultHeader
        {
            scanner -> type.MarkTypeSpecific();
            if (scanner -> type.IsNotSpecified())
                scanner -> Set_CharData_code(ExtendedScanner::CharData_USZip);
            else
            {
                //
                // TODO: set CharData_code appropriately !
                //
                scanner -> type.Reset();
            }

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                cout << "Error detected at location "
                     << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                     << ". The attribute \"";
                for (int i = 0; i < attribute.qname.local_part.length; i++)
                    cout << attribute.qname.local_part.start[i];
                cout << "\" is not valid.\n";
            }
        }
        ./
    
    @postcode ::= '<postcode' postcodeSetup CharData '</' postcode>
        /.$NoAction./
    
    postcodeSetup ::= '>'
        /.$Action
        $DefaultHeader
        {
            scanner -> type.MarkTypeSpecific();
            if (scanner -> type.IsNotSpecified())
                scanner -> Set_CharData_code(ExtendedScanner::CharData_UKPostcode);
            else
            {
                //
                // TODO: set CharData_code appropriately !
                //
                scanner -> type.Reset();
            }

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                cout << "Error detected at location "
                     << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                     << ". The attribute \"";
                for (int i = 0; i < attribute.qname.local_part.length; i++)
                    cout << attribute.qname.local_part.start[i];
                cout << "\" is not valid.\n";
            }
        }
        ./
    
    @Items ::= $empty
        /.$NoAction./
    
    @Items ::= @Items @item
        /.$NoAction./
    
    @Items ::= @Items @confirmedItem
        /.$NoAction./
    
--
-- Since the 'item' element appears only once in this schema, this rule is not needed
--
--    @itemName ::= '<item'
--        /.$Action
--        $DefaultHeader
--        {
--            scanner -> type.SetKind(TK_itemType);
--            scanner -> type.prefix_index = 4;
--        }
--        ./

    --
    -- Note that we use the terminal '<item' here instead of the nonterminal
    -- @itemName. This is because by default, the scanner assumes that an 'item'
    -- element is of type TK_itemType.
    --
    @item ::= '<item' '>' itemTypeSetup @itemType '</' item>
        /.$NoAction./

    @item ::= '<item' '>' confirmedItemTypeSetup @confirmedItemType '</' item>
        /.$NoAction./
    
    itemTypeSetup ::= itemType
        /.$Action
        $DefaultHeader
        {
            bool partNum = false;

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                switch(attribute.Kind())
                {
                    case TK_partNum:
                        if (partNum)
                        {
                            cout << "Error detected at location "
                                 << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                                 << ". The attribute \"";
                                 for (int i = 0; i < attribute.qname.local_part.length; i++)
                                     cout << attribute.qname.local_part.start[i];
                                 cout << "\" was specified more than once.\n";
                        }
                        else
                        {
                            partNum = true;
                            if (! (attribute.att_value.length == 8 &&
                                   Ascii::IsDigit(attribute.att_value.start[1]) &&
                                   Ascii::IsDigit(attribute.att_value.start[2]) &&
                                   Ascii::IsDigit(attribute.att_value.start[3]) &&
                                   attribute.att_value.start[4] == '-' &&
                                   Ascii::IsUpper(attribute.att_value.start[5]) &&
                                   Ascii::IsUpper(attribute.att_value.start[6])))
                            {
                                cout << "Error detected at location "
                                     << (attribute.att_value.start - scanner -> Buffer() + 1)
                                     << ". SKU attribute value was expected.\n";
                            }
                        }
                       break;
                    default:
                        cout << "Error detected at location "
                             << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                             << ". The attribute \"";
                        for (int i = 0; i < attribute.qname.local_part.length; i++)
                            cout << attribute.qname.local_part.start[i];
                        cout << "\" is not valid.\n";
                }
            }
        }
        ./
    
    confirmedItemTypeSetup ::= confirmedItemType
        /.$Action
        $DefaultHeader
        {
            bool partNum = false;

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                switch(attribute.Kind())
                {
                    case TK_partNum:
                        if (partNum)
                        {
                            cout << "Error detected at location "
                                 << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                                 << ". The attribute \"";
                                 for (int i = 0; i < attribute.qname.local_part.length; i++)
                                     cout << attribute.qname.local_part.start[i];
                                 cout << "\" was specified more than once.\n";
                        }
                        else
                        {
                            partNum = true;
                            if (! (attribute.att_value.length == 8 &&
                                   Ascii::IsDigit(attribute.att_value.start[1]) &&
                                   Ascii::IsDigit(attribute.att_value.start[2]) &&
                                   Ascii::IsDigit(attribute.att_value.start[3]) &&
                                   attribute.att_value.start[4] == '-' &&
                                   Ascii::IsUpper(attribute.att_value.start[5]) &&
                                   Ascii::IsUpper(attribute.att_value.start[6])))
                            {
                                cout << "Error detected at location "
                                     << (attribute.att_value.start - scanner -> Buffer() + 1)
                                     << ". SKU attribute value was expected.\n";
                            }
                        }
                       break;
                    default:
                        cout << "Error detected at location "
                             << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                             << ". The attribute \"";
                        for (int i = 0; i < attribute.qname.local_part.length; i++)
                            cout << attribute.qname.local_part.start[i];
                        cout << "\" is not valid.\n";
                }
            }
        }
        ./
    
    @itemType ::= @productName @quantity @USPrice
        /.$NoAction./
    
    @itemType ::= @productName @quantity @USPrice @comment
        /.$NoAction./
    
    @confirmedItemType ::= @productName @quantity @USPrice @shipDate
        /.$NoAction./
    
    @confirmedItemType ::= @productName @quantity @USPrice @comment @shipDate
        /.$NoAction./
    
    @confirmedItem ::= '<confirmedItem' confirmedItemSetup @confirmedItemType '</' confirmedItem>
        /.$NoAction./
   
    confirmedItemSetup ::= '>'
        /.$Action
        $DefaultHeader
        {
            scanner -> type.SetKind(TK_confirmedItemType);
            scanner -> type.prefix_index = 4;
            scanner -> type.MarkTypeSpecific();

            bool partNum = false;

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                switch(attribute.Kind())
                {
                    case TK_partNum:
                        if (partNum)
                        {
                            cout << "Error detected at location "
                                 << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                                 << ". The attribute \"";
                                 for (int i = 0; i < attribute.qname.local_part.length; i++)
                                     cout << attribute.qname.local_part.start[i];
                                 cout << "\" was specified more than once.\n";
                        }
                        else
                        {
                            partNum = true;
                            if (! (attribute.att_value.length == 8 &&
                                   Ascii::IsDigit(attribute.att_value.start[1]) &&
                                   Ascii::IsDigit(attribute.att_value.start[2]) &&
                                   Ascii::IsDigit(attribute.att_value.start[3]) &&
                                   attribute.att_value.start[4] == '-' &&
                                   Ascii::IsUpper(attribute.att_value.start[5]) &&
                                   Ascii::IsUpper(attribute.att_value.start[6])))
                            {
                                cout << "Error detected at location "
                                     << (attribute.att_value.start - scanner -> Buffer() + 1)
                                     << ". SKU attribute value was expected.\n";
                            }
                        }
                       break;
                    default:
                        cout << "Error detected at location "
                             << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                             << ". The attribute \"";
                        for (int i = 0; i < attribute.qname.local_part.length; i++)
                            cout << attribute.qname.local_part.start[i];
                        cout << "\" is not valid.\n";
                }
            }
        }
        ./

    @productName ::= '<productName' productNameSetup CharData '</' productName>
        /.$NoAction./
    
    productNameSetup ::= '>'
        /.$ShareCharDataElementWithoutAttributesAction./
    
    @quantity ::= '<quantity' quantitySetup CharData '</' quantity>
        /.$NoAction./
    
    quantitySetup ::= '>'
        /.$Action
        $DefaultHeader
        {
            scanner -> type.MarkTypeSpecific();
            if (scanner -> type.IsNotSpecified())
                scanner -> Set_CharData_code(ExtendedScanner::CharData_positiveIntegerMaxEx100);
            else
            {
                //
                // TODO: set CharData_code appropriately !
                //
                scanner -> type.Reset();
            }

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                cout << "Error detected at location "
                     << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                     << ". The attribute \"";
                for (int i = 0; i < attribute.qname.local_part.length; i++)
                    cout << attribute.qname.local_part.start[i];
                cout << "\" is not valid.\n";
            }
        }
        ./
    
    @USPrice ::= '<USPrice' USPriceSetup CharData '</' USPrice>
        /.$NoAction./

    USPriceSetup ::= '>'
        /.$Action
        $DefaultHeader
        {
            scanner -> type.MarkTypeSpecific();
            if (scanner -> type.IsNotSpecified())
                scanner -> Set_CharData_code(ExtendedScanner::CharData_decimal);
            else
            {
                //
                // TODO: set CharData_code appropriately !
                //
                scanner -> type.Reset();
            }

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                cout << "Error detected at location "
                     << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                     << ". The attribute \"";
                for (int i = 0; i < attribute.qname.local_part.length; i++)
                    cout << attribute.qname.local_part.start[i];
                cout << "\" is not valid.\n";
            }
        }
        ./
    
    @shipDate ::= '<shipDate' shipDateSetup CharData '</' shipDate>
        /.$NoAction./

    shipDateSetup ::= '>'
        /.$Action
        $DefaultHeader
        {
            scanner -> type.MarkTypeSpecific();
            if (scanner -> type.IsNotSpecified())
                scanner -> Set_CharData_code(ExtendedScanner::CharData_date);
            else
            {
                //
                // TODO: set CharData_code appropriately !
                //
                scanner -> type.Reset();
            }

            //
            // check all attributes here
            //
            for (int i = 0; i < scanner -> attribute_list.Length(); i++)
            {
                AttributeElement &attribute = scanner -> attribute_list[i];
                cout << "Error detected at location "
                     << (attribute.qname.local_part.start - scanner -> Buffer() + 1)
                     << ". The attribute \"";
                for (int i = 0; i < attribute.qname.local_part.length; i++)
                    cout << attribute.qname.local_part.start[i];
                cout << "\" is not valid.\n";
            }
        }
        ./
$End